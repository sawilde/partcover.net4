
// TODO
// DONE: check for failure when serializing and deserializing protobuf classes.
// DONE: error checking when reading optional fields in e.g. ResponseHeader.
// DONE: zero allocation needs some work - need to cache the protobuf stream wrapper for i/ostreams

#ifndef RCF_USE_PROTOBUF
#error RCF_USE_PROTOBUF must be defined for this test.
#endif

#include <RCF/test/TestMinimal.hpp>

#include <fstream>
#include <iostream>

#include <RCF/Idl.hpp>
#include <RCF/InitDeinit.hpp>
#include <RCF/IpServerTransport.hpp>
#include <RCF/RcfServer.hpp>
#include <RCF/TcpEndpoint.hpp>

// These two files are generated by running protoc on
// RCF/test/protobuf/Person.proto.
#include "protobuf/Person.pb.h"
#include "protobuf/Person.pb.cc"

RCF_BEGIN(I_X, "I_X")
    RCF_METHOD_V4(void, echo, const Person &, const Person &, Person&, Person&)
    RCF_METHOD_R1(Person, echo, const Person &)
RCF_END(I_X)

class X
{
public:
    void echo(const Person & person1, const Person & person2, Person & person3, Person & person4)
    {
        person3 = person1;
        person4 = person2;

        //throw std::runtime_error("just testing");
    }

    Person echo(const Person & person)
    {
        Person ret = person;
        //ret.set_name( ret.name() + ret.name() );
        return ret;
    }
};

bool isEqual(const google::protobuf::Message & lhs, const google::protobuf::Message & rhs)
{
    std::ostringstream os1;
    bool ok1 = lhs.SerializeToOstream(&os1);
    std::string s1 = os1.str();

    std::ostringstream os2;
    bool ok2 = rhs.SerializeToOstream(&os2);
    std::string s2 = os2.str();

    return ok1 && ok2 && s1 == s2;
}

int test_main(int argc, char ** argv)
{
    using namespace std;

    RCF::RcfInitDeinit init;

    util::CommandLine::getSingleton().parse(argc, argv);

    RCF::setDefaultRemoteCallTimeoutMs(1000*3600);

    X x;
    RCF::RcfServer server( RCF::TcpEndpoint(0) );
    server.bind<I_X>(x);
    server.start();

    int port = server.getIpServerTransport().getPort();

    // Protobuf serialization

    RcfClient<I_X> client(( RCF::TcpEndpoint(port) ));

    Person person1;
    person1.set_id(123);
    person1.set_name("Bob");
    person1.set_email("bob@example.com");

    Person person2;
    person2.set_id(456);
    person2.set_name("Charlie");
    person2.set_email("charlie@example.com");

    Person person3;
    person3.set_id(0);
    person3.set_name("");
    person3.set_email("");

    assert( person3.IsInitialized() );

    Person person4;
    person4.set_id(0);
    person4.set_name("");
    person4.set_email("");

    assert( person4.IsInitialized() );

    client.getClientStub().setRemoteCallTimeoutMs(3600*1000);

    try
    {
        client.echo(person1, person2, person3, person4);
    }
    catch(const RCF::RemoteException & re)
    {
        RCF_CHECK(1==0);
        std::string s = re.what();
    }
    catch(const RCF::Exception & e)
    {
        RCF_CHECK(1==0);
        std::string s = e.what();
    }

    RCF_CHECK( isEqual(person1, person3) );
    RCF_CHECK( isEqual(person2, person4) );

    // Protobuf marshaling

    // C++ client, protobuf marshaling.
    client.getClientStub().setMarshalingProtocol(RCF::Mp_Protobuf);
    person2 = client.echo(person1);
    RCF_CHECK( isEqual(person1, person2) );

    // C++ client, RCF marshaling.
    client.getClientStub().setMarshalingProtocol(RCF::Mp_Rcf);
    person2 = client.echo(person1);
    RCF_CHECK( isEqual(person1, person2) );

    // C++ client, protobuf marshaling.
    client.getClientStub().setMarshalingProtocol(RCF::Mp_Protobuf);
    person2 = client.echo(person1);
    RCF_CHECK( isEqual(person1, person2) );

    // Python client, protobuf marshaling.
    std::ostringstream os;
    os << RCF_TEMP_DIR "..\\protobuf\\Test_Protobuf.py " << port;
    std::string pyTest = os.str();
    int ret = system( pyTest.c_str() );
    RCF_CHECK(ret == 0);

    return boost::exit_success;
}
